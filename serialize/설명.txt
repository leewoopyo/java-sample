
** 자바 직렬화란?
자바 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 
바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 이야기함.
시스템적으로 이야기하자면 JVM(Java Virtual Machine 이하 JVM)의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술과 
직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태를 같이 이야기함.

** 자바 직렬화 조건
자바 기본(primitive) 타입과 java.io.Serializable 인터페이스를 상속받은 객체는 직렬화 할 수 있는 기본 조건을 가짐.

** 직렬화 방법
자바 직렬화는 방법은 java.io.ObjectOutputStream 객체를 이용.

** 역직렬화 조건
직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며 import 되어 있어야 함.
중요한 점은 직렬화와 역직렬화를 진행하는 시스템이 서로 다를 수 있다는 것을 반드시 고려해야 함.
자바 직렬화 대상 객체는 동일한 serialVersionUID 를 가지고 있어야 함.(필수는 아니지만 관리가 필요한 부분이다.)
    private static final long serialVersionUID = 1L;

** 다른 직렬화 예제
CSV, JSON, Protocol Buffer

** 왜 자바 직렬화를 사용해야 하는가?
CSV, JSON, 프로토콜 버퍼 등은 시스템의 고유 특성과 상관없는 대부분의 시스템에서의 데이터 교환 시 많이 사용됩니다.
하지만 “자바 직렬화 형태의 데이터 교환은 자바 시스템 간의 데이터 교환을 위해서 존재한다.”고 생각해야함.

**자바 직렬화의 장점
자바 직렬화는 자바 시스템에서 개발에 최적화되어 있음. 
복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화, 역직렬화 가능. 
당연하게 보이는 장점 중에 하나지만 데이터 타입이 자동으로 맞춰지기 때문에 관련 부분을 큰 신경을 쓰지 않아도 됨.
그렇게 역직렬화가 되면 기존 객체처럼 바로 사용할 수 있게 됨. 개발자 입장에서 상당히 편한 부분.

** 자바 직렬화는 언제(when) 어디서(where) 사용될까?
JVM의 메모리에서만 상주되어있는 객체 데이터를 그대로 영속화(Persistence)가 필요할 때 사용됨. 
시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송도 가능.
그리고 필요할 때 직렬화된 객체 데이터를 가져와서 역직렬 화하여 객체를 바로 사용할 수 있게 됨.
그런 특성을 살린 자바 직렬화는 많은 곳에서 이용됩니다.

서블릿 세션 (Servlet Session)
서블릿 기반의 WAS(톰캣, 웹로직 등)들은 대부분 세션의 자바 직렬화를 지원하고 있음.
물론 단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 
파일로 저장하거나 세션 클러스터링, DB를 저장하는 옵션 등을 선택하게 되면 세션 자체가 직렬화가 되어 저장되어 전달됨.
(그래서 세션에 필요한 객체는 java.io.Serializable 인터페이스를 구현(implements) 해두는 것을 추천.)
참고로 위 내용은 서블릿 스펙에서는 직접 기술한 내용이 아니기 때문에 구현한 WAS 마다 동작은 달라질 수 있음.

캐시 (Cache)
자바 시스템에서 퍼포먼스를 위해 캐시(Ehcache, Redis, Memcached, …) 라이브러리를 시스템을 많이 이용하게 됨.
자바 시스템을 개발하다 보면 상당수의 클래스가 만들어지게 됨. 
예를 들면 DB를 조회한 후 가져온 데이터 객체 같은 경우 실시간 형태로 요구하는 데이터가 아니라면 메모리, 외부 저장소, 
파일 등을 저장소를 이용해서 데이터 객체를 저장한 후 동일한 요청이 오면 DB를 다시 요청하는 것이 아니라 저장된 객체를 찾아서 응답하게 하는 형태를 보통 캐시를 사용.
캐시를 이용하면 DB에 대한 리소스를 절약할 수 있기 때문에 많은 시스템에서 자주 활용됨.
이렇게 캐시 할 부분을 자바 직렬화된 데이터를 저장해서 사용. 물론 자바 직렬 화만 이용해서만 캐시를 저장하지 않지만 가장 간편하기 때문에 많이 사용됨.

자바 RMI(Remote Method Invocation)
최근에는 많이 사용되지 않지만 자바 직렬화를 설명할 때는 빠지지 않고 이야기되는 기술이기 때문에 언급만 하고 넘어가려고 합니다.
자바 RMI를 간단하게 이야기하자면 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술입니다.
보통은 원격의 시스템과의 통신을 위해서 IP와 포트를 이용해서 소켓통신을 해야 하지만 RMI는 그 부분을 추상화하여 원격에 있는 시스템의 메서드를 로컬 시스템의 메서드인 것처럼 호출할 수 있습니다.
원격의 시스템의 메서드를 호출 시에 전달하는 메시지(보통 객체)를 자동으로 직렬화 시켜 사용됩니다.
그리고 전달받은 원격 시스템에서는 메시지를 역직렬화를 통해 변환하여 사용됩니다.
자세한 내용은 작은 책 한 권 정도의 양이 되기 때문에 따로 한번 찾아보시는 것을 추천드립니다.

** serialVersionUID
직렬화 대상 객체에 serialVersionUID가 설정이 안돼있으면, 객체 정보를 판단하여 해시값으로 serialVersionUID값이 부여된다.
그래서 대상 객체의 정보가 바뀌면(인자 추가) serialVersionUID값이 변하고 가지고 있던 직렬화 데이터로 데이터는 불러올 수 없다.
그래서 serialVersionUID를 객체에 선언함으로서 관리를 해 주어야 한다.
serialVersionUID를 관리함에도 추가로 고려할 사항이, 대상 클래스의 멤버 변수 타입 변동에 주의해야 한다.(자바 역직렬화 시 타입에 매우 엄격함)
        
즉, serialVersionUID값이 동일하다면, 멤버 변수 및 메서드 추가는 크게 문제가 되지 않는다.
그리고, serialVersionUID값이 동일하다면, 멤버 변수 제거 및 이름 변경은 오류는 발생하지 않지만, 데이터가 누락된다.
또 대상 클래스의 멤버 변수 타입 변경을 지양해야 한다.

외부(DB, 캐시 서버, NoSQL 서버 등)에 장기간 저장될 정보는 자바 직렬화 사용을 지양해야 한다. 
역직렬화 대상의 클래스가 언제 변경이 일어날지 모르는 환경에서 긴 시간 동안 외부에 존재했던 직렬화된 데이터는 쓰레기(Garbage)가 될 가능성이 높다.

** 중간 결론
자바 직렬화를 사용할 때에는 될 수 있으면 자주 변경되는 클래스의 객체는 사용 안 하는 것이 좋다. 
변경에 취약하기 때문에 생각지도 못한 예외사항들이 발생할 가능성이 높다. 
특히 역직렬 화가 되지 않을 때와 같은 예외처리는 기본적으로 해두는 것을 추천.
자바 직렬화 기술은 중간에 끼어들 여지가 없는 블랙박스에 가까워서 변경 부분에 취약한 문제가 존재.

** 용량 문제
자바 직렬화시에 기본적으로 타입에 대한 정보 등 클래스의 메타 정보도 가지고 있기 때문에 상대적으로 다른 포맷에 비해서 용량이 큰 문제가 있음.
특히 클래스의 구조가 거대해지게 되면 용량 차이가 커지게 됨. 
예를 들면 클래스 안에 클래스 또 리스트 등 이런 형태의 객체를 직렬화 하게 되면 내부에 참조하고 있는 모든 클래스에 대한 메타정보를 가지고 있기 때문에 용량이 비대해지게 됨.

** 용량 문제 결론
일반 사용자를 대상으로 하는 B2C와 같은 시스템에서 자바 직렬화 정보를 외부 캐시 서버에 저장할 때에는 비효율적인 문제를 가지고 있음. (용량 크기에 따른 네트워크 비용과 캐시 서버 비용)
새롭게 스타트하는 서비스 같은 경우에는 생산성을 위해서 자바 직렬화를 그대로 이용한다고 해도 트랙픽이 지속적으로 증가할 때에는 JSON 형태 또는 다른 형태의 직렬화로 바꿔주는 것 고려해야함.
        

** 결론
자바 직렬화는 장점이 많은 기술이나 단점도 많음. 
문제는 이 기술의 단점은 보완하기 힘든 형태로 되어 있기 때문에 사용 시 제약이 많음. 
그래서 아래와 같은 규칙을 지키는 것이 좋음.

1. 외부 저장소로 저장되는 데이터는 짧은 만료시간의 데이터를 제외하고 자바 직렬화를 사용을 지양.
2. 역직렬화시 반드시 예외가 생긴다는 것을 생각하고 개발.
3. 자주 변경되는 비즈니스적인 데이터를 자바 직렬화을 사용하지 않음.
4. 긴 만료 시간을 가지는 데이터는 JSON 등 다른 포맷을 사용하여 저장.